# CPM
CPM is a small command-line tool I made in C to quickly make C/C++ projects. It can create projects with three different types of structures, and has the ability to fill files with template code through user-configurable `.tmpl` files.

Projects created using CPM always use the GNU Make build system.

v2 has now been finished!

# Features:

## Crossplatform support:
CPM supports both Linux and Windows.

## Multiple Project Structures:
CPM supports creating projects using one of three preset project structures:

- Extended: This generates a `src/` directory, containing three more directories, `main/`, `headers/` and `resources/`. Source files (`.c` or `.cpp` files) are placed in `src/main/`, headers are placed in `src/headers/`, and any miscellaneous resource files are placed in `src/resources`. Output files are separated into an `out/` directory.

- Minimal: This generates only an `src/` directory, and nothing else. Source files and header files are placed in the `src/` directory. Output files are separated into an `out/` directory.

- No folders: This does not generate any subdirectories, and places all files under the project root. Output files are *not* separated.

## Support for C++ project creation
CPM can create C++ projects using separate template files.

## Customizability
You can customize the template code that goes into the 3 files automatically generated by CPM, those being: `main.c` (or `main.cpp`), `main.h` (or `main.hpp`) and the `makefile`.

# Usage
```
usage: cpm <project_name> [options]

available options:
        language options:
        -c             sets the project's language as C (default)
        --cpp          sets the project's language as C++

        project structure settings:
        --extended     uses the extended project structure (default)
        --minimal      uses the minimal project structure
        --no-folders   uses the no folders project structure

        miscellaneous:
        --default      force uses the default template files
        --help (-h)    prints this screen and exits
        --version      prints the current version of CPM running
        --verbose (-v) verbose output
```

## Example Usage:
```bash
cpm test --default --minimal
```
This command creates a project named `test` using the default templates with the minimal project structure setting.

# Installing CPM
To install CPM, you have two choices:
- download a prebuilt release binary, or
- build CPM from source.

## Downloading a CPM release
Simply head over to the [releases](https://github.com/TimeCubed/cpm/releases) page and grab the latest package for your platform. Once downloaded, unzip the files and refer to the [setting up CPM section]() of the readme.

## Building CPM from source
To build CPM from source, first clone the repository on your local machine:

```bash
git clone https://github.com/TimeCubed/cpm.git
```

Next, move into the cloned repository:

```bash
cd cpm
```

Now, depending on your platform, you'll need to do different things.
CPM uses the GNU Make build system, so make sure you have that installed.

To compile CPM for Linux, run:

```bash
make
```

This will use `gcc` as the C compiler to compile CPM with, so make sure you have GCC installed. If you're using a different compiler, make sure to modify this in the makefile and change anything necessary. Note: I haven't compiled CPM using other compilers, so it may not work with other compilers. Likely not, but it might still happen, who knows?

To compile CPM for Windows, run:

```bash
make windows
```

This uses the MinGW32 version of `gcc` built for Linux, which can be found [here](https://www.mingw-w64.org/getting-started/archlinux/). If you are using the Windows version of MinGW32 GCC, you should be able to run this command if the MinGW32 GCC executable is runnable using `gcc`, and you have a Windows version of GNU Make installed, also runnable using `make`.

I recommend using WSL and cross-compiling CPM for windows using that, as it's a lot easier to do this with.

Once CPM is finished compiling, the output is placed under `out/bin/`. This directory contains the finished build.

## Setting up CPM
Now that you have all the required files, all you need to do is move the `bin/` directory to somewhere comfortable.

On Linux, you can create a symbolic link to CPM using:

```bash
sudo ln -s /absolute/path/to/bin/cpm /usr/bin/cpm
```

This will create a soft symbolic link to your CPM executable, and you can now run `cpm` in your terminal freely. Another way to do this is to add `path/to/bin/cpm` to your `PATH` environment variable.

On Windows, you'll have to add the CPM executable to your `PATH` environment variable in order to run it globally.

After finishing these steps, you should have a working install of CPM on your machine.

# Customizing CPM
When CPM is started, it will look inside `~/.config/cpm/templates/` (or `C:\Users\your_user\AppData\Local\cpm\templates\` on Windows) for any `.tmpl` files. Specifically, if you're creating a C project, it'll look inside `~/.config/cpm/templates/c/` (or the corresponding directory on Windows) for three files: `templates-extended.tmpl`, `templates-minimal.tmpl` and `templates-no-folders.tmpl`. These are used for the extended, minimal and no folders project structures respectively. If you're creating a C++ project, then it'll look inside `~/.config/cpm/templates/cpp/` (or the corresponding directory on Windows) for the same three files.

The following is an example of the structure of a `.tmpl` file:

```
[main.c]
#include <main.h>

int main(void) {
    printf("hello, world!\n");
}

[main.h]
#ifndef MAIN
#define MAIN

#include <stdlib.h>
#include <stdio.h>

#endif

[makefile]
CC := gcc
LFLAGS := -I ./src/headers/

all:
    @mkdir -p out/bin/
    $(CC) src/main/main.c -o out/bin/example $(LFLAGS)
```

CPM will look inside the correct `.tmpl` file for the current project structure for three sections: `main.c`, `main.h` and `makefile` for the data to put inside the files it generates. A section is defined by a name wrapped inside two square brackets at the start of a line.

To create a custom template for CPM to use, all you need to do is head to CPM's config directory, create a `c/` or `cpp/` directory, then create a `.tmpl` file matching the name for the project structure you want the `.tmpl` file to work with.

For example, to create a template for the extended project structure for C projects, create the directory `~/.config/cpm/templates/c/` using: (linux only. for windows, create the directories manually)

```bash
mkdir -p ~/.config/cpm/templates/c/
```

and then create a file called `templates-extended.tmpl` in that directory. You can then populate this file with the three sections needed for CPM, and add any code you want to each section.

**Important note: When creating the `makefile` section, make sure to use tabs and not spaces for indentation. GNU Make does not recognize space indentation.**

CPM will always prioritize user config files over the default ones, though this can be overridden by running CPM with the `--default` flag, which will always use the default template files.

# Contribution
Just make a PR! Usual GitHub stuff, y'know?

## Future v3 roadmap

For a future v3, I'm planning to allow CPM to not only create C/C++ projects, but also allow it to
be configurable enough to make projects of any kind, probably even to be used as a way to quickly
make boiler-plate directory structures. To allow for this, each .tmpl file would have to specify
more than just template code, but instead specify the layout and structure of a project. This would
mean that you no longer would have multiple project templates for one language (future update ??),
but it would mean you could make a template for *any* language.

Also, since this is a "for the future" type of todo-list, I might also consider completely scrapping
the custom format in favor of using YAML or whatever. The only reason I'm using a custom format is
that I only needed to have text data stored under some label, and also to make it easy to write your
own templates without having to add '\n's everywhere or something like that. If I find something
that fits my requirements, I'll probably use that instead, since writing a custom parser for a
custom file format involves a lot more stuff than what I'm doing right now.

This todo-list is more of a future roadmap rather than a fully in-depth technical breakdown of what
needs to be changed (even if it seems detailed), and is very much a "far into the future" kind of
thing. It's for a 'v3', meaning a 'v2' is supposed to happen first.

- [ ] Rework CLI arguments parser (or maybe use getopt?)
    - [ ] Add a way to accept a language as an input
- [ ] .tmpl file format rework
    - [ ] Add area to specify project structure
    - [ ] Rework sections to allow the specification of where each file goes relative to the project structure
- [ ] Rework tmplparser.c and .tmpl format (or maybe use a pre-existing format?)
    - [ ] Add checks for invalid project structure
    - [ ] Add checks for invalid directory (not under a directory in specified project structure)
    - [ ] User feedback on errors
    - [ ] Add a function to read all sections
    - [ ] Add a Section struct to represent a section (name, path, contents)
- [ ] Rework how projects are represented internally
    - [ ] Add a ProjectFile struct array into the ProjectConfig struct instead of hardcoding files
    - [ ] Add a more robust system for representing project structures
- [ ] Rework confighandler.c
    - [ ] Load the correct .tmpl file according to the language
    - [ ] Read the project structure
    - [ ] Read all sections from the file
    - [ ] Add each section as a project file to the project config
- [ ] Rework builder.c
    - [ ] Make directories based on the project config (potentially recursively?)
    - [ ] Make files based on the project config
